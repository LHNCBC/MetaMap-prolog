:- multifile sccs_id/1.
:- dynamic sccs_id/1.

sccs_id('@(#)messages.pl	1.9 03/26/07').

:- dynamic error_or_warning_message/3.


% Code for generate_message_hook/3 provided by Mats Carlsson of SICS
% to handle error messages generated by load_foreign_executable,
% which seem to be "slightly non-standard".
% E-mail from Mats 03/26/2007.

:- multifile user:generate_message_hook/3.

user:generate_message_hook(permission_error(Goal,_Operation,ObjectType,_Culprit,_Message)) -->
	{Goal = load_foreign_executable(_)},
	{\+'QU_messages':typename(ObjectType,_,_)},
	['Permission error'-[], nl],
	[ObjectType-[], nl],
	'QU_messages':goal(Goal).
user:generate_message_hook(existence_error(Goal,_ArgNo,ObjectType,_Culprit,_Message)) -->
	{Goal = load_foreign_executable(_)},
	{\+'QU_messages':typename(ObjectType,_,_)},
	['Existence error'-[], nl],
	[ObjectType-[], nl],
	'QU_messages':goal(Goal).

% generate_message_hook/3 is the user's version of generate_message/3,
% which is defined in QU_messages

% relevant_message_term(syntax_error(_,_,_,_,_,_)).
% relevant_message_term(clauses_not_together(_)).
% relevant_message_term(singleton_variables(_,_,_,_)).

:- multifile user:message_hook/3.

% When Prolog gets to the FIRST top level prompt,
% re-display all the errors and warnings that were
% originally displayed during the initial compilation.
% Finally, abolish message_hook/3.

message_hook(top_level(_Module, _Level, _Dstate), Severity, Lines) :-
	!,
	severity_prefix(Severity, Prefix, Stream),
        print_message_lines(Stream, Prefix, Lines),
	print_all_startup_errors.

% The code below for message_hook/3 is a modified copy of the code
% in the QP manual under message_hook/3.
message_hook(MessageTerm, Severity, Lines):-
	% msg_info(Severity, user_output, '~n### MH #### ~q:~q~n', [Severity,MessageTerm]),
        ( Severity == silent ->
          true
          % Don't translate or print silent messages
        ; severity_prefix(Severity, Prefix, Stream) ->
	  % msg_info(Severity, user_output, 'PRINTING MESSAGE LINES~n', []),
          print_message_lines(Stream, Prefix, Lines)
	  % ( ( Severity == error ; Severity == warning ) ->
	  %     format('MessageTerm 1: (~w) ~q~n', [Severity,MessageTerm])
	  %    ; true
	  % )	   
        ; format(user_output, 'RAISING EXCEPTION~n', []),
	  raise_exception(domain_error(
             print_message(Severity, MessageTerm),1,
             one_of([help,error,warning,informational,silent]),
             Severity))
	),
	store_relevant_message(Severity, MessageTerm).

msg_info(Severity, Stream, FormatString, FormatArgs) :-
	( Severity == warning ->
	  true
        ; Severity == error
        ),
	!,
	format(Stream, FormatString, FormatArgs).
msg_info(_Severity, _Stream, _FormatString, _FormatArgs).

severity_prefix(silent,        '',   user_error).
severity_prefix(help,          '',   user_error).
severity_prefix(error,         '! ', user_error).
severity_prefix(warning,       '* ', user_error).
severity_prefix(informational, '% ', user_error).

store_relevant_message(Severity, MessageTerm) :-
	% msg_info(Severity, user_output, '~n### SRM 1a #### ~q:~q~n', [Severity,MessageTerm]),
	( Severity == error ->
	  true
        ; Severity == warning
    	),
	!,
	% msg_info(Severity, user_output, '~n### SRM 1b ####~n', []),
	( 'QU_messages':generate_message(MessageTerm, MessageLines, []) ->
	   true
        ; MessageLines = 'UNFORMATTED'
        ),
	% msg_info(Severity, user_output, '~n### SRM 1c ####~n', []),
	% assert(user:error_or_warning_message(Severity, MessageTerm))
	% msg_info(Severity, user_output, '### Asserting ~q~n',
	%         [error_or_warning_message(Severity, MessageTerm, MessageLines)]),
	assert(user:error_or_warning_message(Severity, MessageTerm, MessageLines)).

store_relevant_message(Severity, MessageTerm) :-
	msg_info(Severity, user_output, '~n### SRM 2 #### ~q:~q~n', [Severity,MessageTerm]).

print_all_startup_errors :-
	( user:error_or_warning_message(_Severity, _MessageTerm, _MessageLines) ->
	  print_all_startup_errors_1
        ; abolish(message_hook, 3)
        ).
	% abolish(message_hook, 3).

print_all_startup_errors_1 :-
	format(user_output, '~n~n~*c~n~*c~n', [80,35,80,35]),
	format(user_output, '~*c Errors found while compiling.~*c~n', [25,35,25,35]),
	format(user_output, '~*c~n~*c~n~n', [80,35,80,35]),
	retract(user:error_or_warning_message(Severity, MessageTerm, MessageLines)),
	% format(user_output, '~n### RETRACTED ~q~n~q~n~q~n', [Severity, MessageTerm, MessageLines]),
	severity_prefix(Severity, Prefix, Stream),
	% relevant_message_term(MessageTerm),
	% format('~n### MessageTerm 2 (~q):~q ~n',   [Severity,MessageTerm]),
	% format('~n### MessageLine 2 ~q ~n~n', [MessageLines]),
	listify_message_lines(MessageLines, ListifiedMessageLines),
	my_print_message_lines(Stream, Prefix, MessageTerm, ListifiedMessageLines),
	% print_message(Severity, MessageTerm),
	% format('~n### MessageText:     ~q ~n', [MessageLines]),
	% format('~n### MessageTextRest: ~q ~n', [Rest]),
	fail.

% The message hook is designed to print messages just before the
% very first top-level Prolog prompt (after initial compilation),
% so once that's done, just abolish the message hook.
print_all_startup_errors_1 :-
	retractall(user:error_or_warning_message(_,_,_)),
	abolish(message_hook, 3).

listify_message_lines('UNFORMATTED', 'UNFORMATTED').
listify_message_lines([H|T],         [[H|T]]).

% The code for my_print_message_lines/3 is a modified copy of the code
% in the QP manual under print_message_lines/3.
% I believe the code in the QP manual is incorrect.

my_print_message_lines(Stream, Prefix, MessageTerm, Lines):-
	% format(user_output, '~n### MPL ### ~q~n~q~n~q~n', [Prefix, MessageTerm, Lines]),
	( Lines == 'UNFORMATTED' ->
	  format(Stream,'~N~w~w~n~n', [Prefix,MessageTerm])
        ; member(Line,Lines),
          ( member(C-A,Line),
	    format(Stream,'~N~w',[Prefix]),
            format(Stream,C,A),
	    nl(Stream)
          ; nl(Stream)
          ),
         fail
        ).
my_print_message_lines(_, _, _, _).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Allow non-interactive tracing of specific predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

create_message_hook_term(ValidPredicates, MessageHookTerm) :-
	( ValidPredicates == [] ->
	  format(user_output, '~nNo valid predicates to trace.~n', []),
	  !,
	  fail
   	; MessageHookTerm = ((
	    user:message_hook(debugger(_,_,_,_,_,_,_,Goal,_,_),help,_) :-
		    ( Goal = _Module:Term ->
		      functor(Term, F, A),
		      \+ memberchk(F/A, ValidPredicates)
		    ; functor(Goal, F, A),
		    \+ memberchk(F/A, ValidPredicates)
		    ),
		    !))
	).

write_message_hook_file(MessageHookTerm, MessageHookFile) :-
	MessageHookFile = '/var/tmp/message_hook_$$.pl',
	open(MessageHookFile, write, OutputStream),
	set_output(OutputStream),
	portray_clause((:- abolish(message_hook, 3))),
	nl(OutputStream),
	portray_clause((:- multifile user:message_hook/3)),
	nl(OutputStream),
	portray_clause((:- no_style_check(single_var))),
	nl(OutputStream),
	portray_clause(MessageHookTerm),
	nl(OutputStream),
	portray_clause((:- style_check(single_var))),
	nl(OutputStream),
	portray_clause((:- emacs_debugger(_, off), leash([]), trace)),
	nl(OutputStream),
	close(OutputStream).
	
notrace_predicate :- no_trace_predicate.

no_trace_predicate :-
	notrace,
	leash(all),
	emacs_debugger(_, on),
	abolish(message_hook, 3).

trace_predicate(Predicate, Arity) :-
	no_trace_predicate,
	trace_all_predicates([Predicate/Arity]).

trace_predicate(Predicates) :-
	no_trace_predicate,
	( atom(Predicates) ->
	  expand_one_predicate(Predicates, ExpandedPredicateList)
	; Predicates = _Functor/_Arity ->
	  ExpandedPredicateList = [Predicates]
	; expand_predicates(Predicates, ExpandedPredicateList)
	),
	trace_all_predicates(ExpandedPredicateList).

trace_all_predicates(Predicates) :-
	validate_predicates(Predicates, ValidPredicates),
	nl(user_output),
	announce_traced_predicates(ValidPredicates),
	nl(user_output),
	create_message_hook_term(ValidPredicates, MessageHookTerm),
	write_message_hook_file(MessageHookTerm, MessageHookFile),
	compile(MessageHookFile).
	
expand_predicates([], []).
expand_predicates([H|T], ExpandedPredicates) :-
	expand_one_predicate(H, ExpandedH),
	expand_predicates(T, ExpandedT),
	append(ExpandedH, ExpandedT, ExpandedPredicates).

expand_one_predicate(Functor/Arity, [Functor/Arity]).
expand_one_predicate(PredicateName, ExpandedPredicates) :-
	atom(PredicateName),
	( setof(Functor/Arity,
		Module^Skeletal^(current_predicate(PredicateName, Module:Skeletal),
			functor(Skeletal, Functor, Arity)),
	        ExpandedPredicates) ->
	  true
	; ExpandedPredicates = []
	).

validate_predicates([], []).
validate_predicates([H|T], ValidatedPredicates) :-
	H = Functor/Arity,
	( current_predicate(Functor, _Module:SkeletalSpecification),
	  functor(SkeletalSpecification, Functor, Arity) ->
	  ValidatedPredicates = [H|RestValidatedPredicates]
	; current_predicate(Functor, _SkeletalSpecification) ->
	  ValidatedPredicates = [H|RestValidatedPredicates]
	; format('~n~q/~w is not a known predicate~n', [Functor,Arity]),
	  ValidatedPredicates = RestValidatedPredicates
	),
	validate_predicates(T, RestValidatedPredicates).

announce_traced_predicates([]).
announce_traced_predicates([H|T]) :-
	H = Functor/Arity,
	announce_one_traced_predicate(Functor, Arity),
	announce_traced_predicates(T).

announce_one_traced_predicate(Functor, Arity) :-
	format(user_output, 'Tracing ~q/~w~n', [Functor, Arity]).
